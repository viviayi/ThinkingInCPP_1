# 函数重载与默认参数
函数重载对构造函数必须，都以类名为函数名，用不同的参数类型区分。  
对于其他的任意函数，也可以使用重载，只要参数列表不同即使两个库中有同名函数也不会冲突。
## 名字修饰
### 用返回值重载（no）
`void f(); int f();` 使用时无法知道是调用了哪一个函数
### 类型安全连接
page 163  
错误的声明函数以后，c++中编译以后连接会报错，即类型安全连接

## 重载
例子，Stash3.h

## 联合
union 也可以带有构造函数、析构函数、成员函数及访问控制，重载见例:UnionClass.cpp  
union和class的唯一不同之处在于存储数据的方式（union中各种类型的数据在同一内存去覆盖存放），但union不能在继承时作为基类使用  
上面例子中的union无法阻止不恰当的调用，更安全的方法是封装在类中，见SuperVar.cpp

## 默认参数
默认参数是在函数声明时就已给定一个值的参数，如果在调用函数时没有指定这一参数值，编译器会自动插上这个值。  
`Stash(int size); Stash(int size, int initQuantity);`  
`Stash(int size, int Quantity=0);`  
使用默认参数简化了重载函数。但是不适用于函数行为差异较大的两个函数。  
规则：
- 只有参数列表的尾部参数可以是默认的，不可在默认参数后面再加非默认参数
- 函数调用时，使用了一个默认参数，则该参数后面的参数都必须默认   
- 默认参数只能放在函数声明中，通常在头文件中
### 占位符参数
`void f(int x, int, float flt);`  
在函数体中x和flt都可以引用，但中间的int参数不可以，因为没有参数名。这种语法允许将一个参数作为占位符而不使用，目的在于：
- 之后可以修改函数定义，如添加这个参数，且不用修改所有对这个函数的调用。
- 删除某个不需要的函数参数，采用占位符去掉这个参数时不会产生警告，也不需要修改调用的代码

## 重载或默认？
- **不能把默认参数作为判断标志**，在需要这种判断的情况下，应该把函数分成多个重载的函数。  
- 一个默认的参数应该是在一般情况下会出现在这个位置的值，且出现的概率比其他值大，因此客户程序员可以选择忽略它，或在某些特殊情况下才去使用它