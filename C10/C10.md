# 名字控制
## static
- 静态存储：在固定地址上进行存储分配，即对象在一个特殊的静态数据区上创建，不是每次函数调用时在堆栈上产生
- 局部可见：控制名字的可见性，在单元或类外不可见

### 函数内部静态变量
存储在静态数据区，只在函数第一次调用时初始化一次，在以后的函数调用之间保留变量值。**内部类型**的静态变量不提供初始值时，编译器在程序开始时将其初始化为零（用户自定义的类型必须要构造函数初始化）。  
！！！易产生多线程问题  
### 控制连接
- 外部连接：在文件作用域内的所有名字（不嵌套在类或函数中的名字），对程序中的所有翻译单元来说可见，即外部连接。全局变量和普通函数都有外部连接。
- 内部连接：文件作用域内被明确声明为static的对象或函数的名字有内部连接，局部属于其出现声明的.cpp翻译单元。
### 静态存储和局部可见含义
`int a = 0;` 全局变量，静态存储，默认外部连接  
`extern int a = 0;` 与上相同  
`static int a = 0;` 改变了a的可见性，变成局部变量，但还是存储在静态数据区  
`void f();` 与 `extern void f();` 相同，外部连接  
`static void f();` 则只在本翻译单元内可见，文件静态  

## 名字空间 namespace
#### 与class、struct、union、enum区别
- 只能在全局范围内定义，但可以互相嵌套
- 定义结尾}不用分号
- 一个namespace可以在多个头文件中用一个标识符定义，好像重复定义一个类
- 可以用另一个名字作为别名`namespace Bob = BobSuperDuperLibrary`,其中BobSuperDuperLibrary是定义的命名空间
- namespace不能像类一样创建实例
#### 未命名的namespace
每个翻译单元可包含一个未命名的名字空间，只用namespace，自动在翻译单元内有效，里面的局部名字不需加static即可作为内部连接
#### 友元
名字空间里的类定义中可以插入友元声明，则友元函数成为名字空间中的成员

### using
`using namespace MySpace;` 使用指令（using directive），声明名字空间中的所有名字是在当前范围内。可以把一个名字空间中的所有名字引入到另一个名字空间中。其可见范围是在使用using的地方。会作为当前范围的全局名字。可能由于引入不同名字空间而重复定义一个函数。  
`using MySpace::Myfunc;` 使用声明（using declaration），一次性引入名字到当前范围，如果名字空间中有一组相同名字的重载函数，则using声明声明了所有重载的函数。不会引起二义性和重复。  

## C++中的静态成员
目的：全局变量可以被任何人修改，需要隐藏在类内部且像全局变量那样存储  
### 静态数据成员
类的静态数据成员不管类产生了多少对象都有单一存储空间，需要单独定义，出现在类的外部（不能内联），定义一次  
```
class A{
    static int i;
    //...
};
int A::i = 1; // 静态数据成员定义，只出现一次，且由类的构造者控制
int global_i = 1; // 普通全局变量定义
```
局部类（函数内部定义的类）中不可有静态数据成员  
### 静态成员函数
为类的全体对象服务，可以使用作用域调用，不需要具体对象`X::f();`  
将函数与类在概念上关联  
- 不能访问一般数据成员，只能访问静态数据成员，和调用其他静态成员函数
- 没有this
可以将类构造函数定义为私有，在类内部定义静态成员对象，这样这个类只有一个唯一对象，可以访问但无法产生新的类对象（见Singleton.cpp）

## 静态初始化的相依性
问题：作用域为多个翻译单元的静态对象，不能严格保证初始化的顺序  
在一个文件中初始化out对象，另一个文件中使用，如果第二个文件先初始化则会引起混乱  
解决：
- 技术一：库头文件中添加一个初始化类，负责库中静态对象的动态初始化（见Initializer.h）
- 技术二：利用函数内部的静态对象在函数第一次调用时初始化，且只初始化一次。将静态对象写在函数中，则会根据代码调用顺序进行初始化。（见Technique2.cpp）

## 替代连接说明
c++中用到C库:`extern "C" float f(int a, char b);`告诉编译器f是C连接