# 内联函数
问题：在C中为了效率使用预处理器宏，看起来像函数调用，但并不总是这样，会有隐藏错误；C++的预处理器不允许访问类的成员数据，因此不能用作类的成员函数
## 预处理器的缺陷
`#define FLOOR(x,b) x>=b?0:1` 在使用时如果使用`if(FLOOR(a&0x0f,0x07))`则会被宏展开变成`if(a&0x0f>=0x07?0:1)`，由于&优先级低，所以结果和预期不同，会先运算>=。（另例见MacroSideEffects.cpp，多个条件会多次测试从而产生多次自增副作用）  

## 内联函数
C++中宏的概念作为内联函数实现，与普通函数的区别在于可以在适当的地方像宏一样展开，减少函数调用的开销。  
- 类中定义的函数自动成为内联函数
- 可以在非类的函数前加inline成为内联函数，但必须函数体和声明结合在一期，否则无效
- 放在头文件中定义

### 访问函数
读取或修改几个内部变量的**小函数**（访问器和修改器），对私有数据成员的访问只能通过函数接口进行，定义为内联函数效率更高。

### 限制
- 函数太复杂则编译器不能执行内联
- 任何种类的循环都视为太复杂
- 需要显式或隐式取函数地址的，编译器不能执行内联，因为必须为函数代码分配内存产生函数地址

## 预处理器其他特征
- 字符串定义：使用#，取一个标识符并转化为字符数组
- 字符串拼接：两个相邻字符串，没有分隔符时，自动组合  `#define TRACE(s) cerr << #s << endl, s` 则TRACE可以放入for循环中，不会因为有两个语句只执行第一个
- 标志粘贴：使用##实现，设两个标识符并粘贴在一起产生新的标识符，`#define FIELD(a) char* a##_string; int a##_size` 使用时FIELD(one)会产生one_string和one_size两个标识符    