# 继承和组合
组合：在新类中创建已存在类的对象，嵌入对象称为子对象  
继承：创建一个新类作为一个已存在类的类型。不修改已存在的类，在其基础上加入代码  
## 继承语法
`class Y : public X{};`见例程Simple inheritance   
- Y将包含X中所有数据成员和成员函数。
- 继承时基类所有成员默认private，所有需要public关键字。
- 派生类可以直接访问所有基类的公有函数
- 派生类可以重定义基类的函数，派生类的对象调用派生类的函数，未重定义的会调用基类函数。当重定义后又需要调用基类函数时，采用作用域运算符`X::set(ii);`

## 构造函数初始化表达式
如果子对象没有默认构造函数、或想改变构造函数的某个参数，则由于新类的构造函数无权访问子对象的私有数据成员而不能直接对其初始化。解决方式是使用构造函数初始化表。将对子对象构造函数的调用语句放在构造函数参数表和冒号之后，函数体前。  
如`MyType::MyType(int i) : Bar(i){//...};`

## 组合+继承
只有通过继承才能重新定义基类的函数，对于成员对象只能操作其公共接口，不能重定义它。  
析构函数调用：从派生最底层的析构函数开始调用，一直到根层。构造和析构函数每层都调用，普通函数只是那个函数被调用。

### 构造函数和析构函数调用次序
见例程Order.cpp  
构造函数从类层次的最根处开始，每一层都先调用基类构造函数，再调用成员对象构造函数。析构函数严格按照构造函数相反次序。对于成员对象，构造函数调用次序取决于其在类中的声明次序。

## 名字隐藏
任何时候重新定义了基类中的一个重载函数，新类之中其他版本自动隐藏。改变返回类型或参数表重新定义基类函数，也会隐藏基类中的函数版本。

## 非自动继承的函数
构造函数、析构函数、operator=都不能被继承，必须为每一个特定的派生类分别创建。但自动类型变换运算可以继承。见例程SynthesizedFunctions.cpp  
编译器可以自动生成不能继承的构造函数和赋值运算符，但一旦决定自己定义，编译器不会再自动调用基类版本，需要显示调用。`Checkers(const Checker& c) : Game(c){`
### 继承和静态成员函数
静态成员函数不可以是虚函数。

## 组合和继承选择
is-a：继承，has-a：组合
### 子类型化
见例程FName2.cpp  
当只需要使用基类中的一部分时，组合是使用的，但如果希望基类中每件东西都进入新类，则需要继承，将新类“子类型化”。新类与已存在的类有严格相同的接口，可以增加其他成员函数，所有使用过基类的地方都可以使用这个新类。
### 私有继承
目的：产生像基类接口一样的接口，但不允许新类对象的处理和基类对象相同，隐藏基类的部分功能。
#### 私有继承部分成员公有化
见例程PrivateInheritance.cpp，用派生类的public 部分声明成员名，`using Pet::eat;`。  
当给出一个重载函数的名字会将基类所有的重载版本都公有化。

## protected
在类中声明protected意义：该成员对这个类的对象是私有的，但派生类中可以使用

## 运算符的重载与继承
除赋值运算符外都可自动继承到派生类中。

## upcasting向上类型转换
继承的新类和基类之间的关系是：新类属于原有类的类型。因此所有作用于基类的函数都可以作用于新类，进行向上的类型转换。见例程Instrument.cpp
### 向上类型转换和拷贝构造函数
编译器给派生类自动生成拷贝构造函数，会先自动调用基类拷贝构造函数，然后是各成员对象拷贝构造函数。见例程CopyConstructor.cpp。无论何时创建了自己的拷贝构造函数时，都要正确调用基类拷贝构造函数。

### 组合与继承
如果发现一个程序中可以使用组合代替继承，则可以消除多重继承的需求。

### 指针和引用的向上类型转换
```
Wind w;
Instrument* ip = &w;
Instrument& ir = w;
```
### 问题
任何向上类型转换都会损失对象的类型信息。
