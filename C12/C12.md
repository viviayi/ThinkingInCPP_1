# 运算符重载
运算符重载只是另一种函数调用方式。
与函数调用的不同：
- 语法不同，运算符在参数之间或之后
- 由编译器决定调用哪一个运算符
## 两个极端
滥用—>只有在能使涉及类的代码更容易写，尤其是更易读时，才有理由重载运算符。
恐慌—>仅包含内置数据类型的表达式中的所有运算符都是不可能改变的；只有包含用户自定义类型的表达式才能有重载的运算法。
## 语法
与定义函数类似，函数名变为operator@，参数表中参数个数取决于：
- 运算符是一元（一个参数）还是二元的（两个参数）
- 运算符被定义为全局函数还是成员函数（一元无参，二元一个参数——该类对象用作左侧参数）
## 可重载的运算符
限制：不能使用C中当前没有意义的运算符（如**），不能改变运算符优先级，不能改变运算符的参数个数。  
### 一元
见例程 OverloadingUnaryOperators.cpp  
#### 自增和自减
有前缀、后缀两种形式，不同的重载函数`operator++(a)`对应++a，`operator++(a,int)`对应a++
### 二元
例程Integer.h等、Byte.h等  
operator=只允许作为成员函数  
所有赋值运算符都有代码检测自赋值（self-assignment）
### 参数和返回值
- 任何函数参数，如果仅需要从参数中读而不改变它，默认应当作为**const引用**来传递。  
  当函数是一个类成员函数时，就转换为const成员函数。只有会改变左侧参数的赋值运算符，如operator+=和operator=，左侧参数不是常量，但因为参数将被改变，所以参数仍按地址传递。`Byte& operator+=(const Byte& right);`
- 返回值类型取决于运算符具体含义。如果该运算符结果是产生一个新值，就需要产生一个新对象，作为返回值。如operator+。新对象作为一个常量通过传值方式返回，结果不会被改变。`const Integer operator+(const Integer& left, const Integer& right);`
- 所有赋值运算符均改变左值，需要返回一个改变了的左值的引用。由于人们有时希望能堆刚刚赋值的对象进行运算，如`(a=b).fun()`，因此所有赋值运算符的返回值对于左值应该是非常量引用。`Integer& operator+=(Integer& left, const Integer& right);`
- 逻辑运算符的返回值最好是bool，至少是int
- 自增和自减：参数被改变，非常量引用，前缀返回参数引用，后缀传值返回改变前的对象。由于可能有`(++a).func()`，的使用，因此前缀返回非常量，可改变。但对于`(a++).func()`，后缀自增返回的是临时对象，编译器自动定位常量，操作报错，因此可定义后缀返回常量。  
  `Integer& operator++(Integer& a);`  
  `const Integer operator++(Integer& a, int);`
#### 返回值优化
不优：`Integer tmp(left.i + right.i); return tmp;` 会创建tmp对象，调用构造函数，然后通过拷贝构造函数将tmp拷贝到外部返回值的存储单元，最后tmp析构  
更优：`return Integer(left.i + right.i);` 直接把对象创建在外部返回值的内存单元，只需要调用普通构造函数，不调用拷贝构造和析构函数。
### 不常用的运算符
#### `operator[]`
必须是成员函数，且只接受一个参数。
#### `operator,`
确实好像没啥用
#### `operator->`
灵巧指针（指针间接引用运算符）。一定是一个成员函数。额外限制：必须返回一个对象（或对象的引用），该对象也有一个指针间接引用运算符；或必须返回一个指针，被用于选择`->`指向的内容，见例程SmartPointer.cpp
#### `operator->*`
要想创建一个`operator->*`必须先创建带有`operator()`类，见例程PointerToMemberOperator.cpp  
### 不能重载的运算符
- 成员选择运算符`operator.`
- 成员指针间接引用运算符`operator.*`
- 求幂运算符，c没有
- 不存在用户定义的运算符
- 不能改变优先级规则

## 非成员运算符  
总的来说，如果成员和非成员没什么差异，应该定义为成员运算符，强调运算符和类的联合。但有时运算符左侧是别的类的对象，如输入输出流重载（operator<< / operator>>），则只能定义为非成员运算符。  
成员和非成员选择建议（Murray）：  
| 运算符 | 建议使用 |  
|--------|------------|
| 所有一元运算符 | 成员 |
| = () [] -> ->* | 必须成员 |
| += -= /= *= ^= &= \|= %= >>= <<=>> | 成员 |
| 其他二元运算符 | 非成员 |

## 重载赋值符
初始化时可以使用=替代显示调用构造函数(或拷贝构造函数)，如`Fee fee(1);`可以写成`Fee fee = 1;`，而`Fee fum(fi);`可以写成`Fee fum = fi;`  
### `operator=`的行为
必须是成员函数，避免全局影响内置的'='  
自赋值：当准备给两个相同类型的对象赋值时，应该首先检查一下自赋值（self-assignment）：这个对象是否对自身赋值了  
#### 类中指针
对象里包含指向别的对象的指针时，两个解决方案：
- 当做一个赋值运算或一个拷贝构造函数时，拷贝这个指针所涉及的一切，见例程CopyingWithPointers.cpp
- 写拷贝，见引用计数
#### 引用计数
为了避免每次都拷贝大量对象，采用引用计数的方式，拷贝构造函数或赋值运算意味着把另外的指针指向现在的存储单元并增加引用计数，消除意味着减少引用计数，当引用计数为0则意味着销毁这个对象。  
在写入之前确认引用计数，若大于1，则在写之前必须先拷贝这块存储单元，以防影响其他对象。见例程 ReferenceCounting.cpp，控制所有写存储单元的动作，例程中使用unalias()防止修改已经别名化的存储单元（超过一个对象使用）。
#### 自动创建`operator=`
编译器会自动创建，模仿自动创建的拷贝函数行为：如果类包含对象（或从别的类继承），对于这些对象，`operator=`被递归调用，成为成员赋值。见例程AutomaticOperatorEquals.cpp

## 自动类型转换
使用**特殊类型的构造函数**和**重载的运算符**为用户定义的类型实现 当表达式或函数调用使用了不合适的参数类型时，编译器执行自动类型转换。  
创建一个单一参数的构造函数总是定义一个自动类型转换，有时候我们并不需要，则需要用explicit避免，另外构造函数没办法将用户定义的类型转换为内置类型，而运算符重载可以。
### 构造函数转换
特殊的构造函数：把另一种类型对象（或引用）作为单个参数的构造函数。见例程AutomaticTypeConversion.cpp。避免了定义两个函数调用重载版本，代价是调用隐藏构造函数，执行效率会降低。
#### 阻止构造函数转换
使用`explicit`(只用于构造函数)使构造函数显示化，禁止构造函数被用于自动类型转换，只能用户显示调用。
### 运算符转换
创建一个成员函数，在operator后跟随想要转换到的类型，如`operator MyType1() const{ return MyType1(i); }`是类MyType2中的成员函数，能用于将MyType2类型转换为MyType1。具体可见例程OperatorOverloadingConversion.cpp
#### 反身性
最好使用全局重载运算符，原因是全局的自动类型转换可以针对左右任一操作数，而成员版必须保证左侧操作数已经是正确类型。见例程ReflexivityInOverloading.cpp
### 自动类型转换的缺陷
- 同时存在两种类型转换方法（如构造函数和运算符重载都有）时，编译器会报错。
- 扇出（fan-out），当存在不止一种类型的自动转换时，可以转换到多种不同类型。
- 引入隐藏行为，创建拷贝函数等
**小心使用**